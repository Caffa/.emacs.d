#!/usr/bin/env ruby

=begin
Git Elpa
========

This module is used to simplify updating Emacs ELPA packages.

In this Emacs config, unlike most, I maintain a repository history of
the ELPA packages I install. Usually (99% of the time over many years
so far) I have no issues with this at all.  Of course, hypothetically,
it's quite possible that any feature of any package could be broken at
any time.

In case a breakage occurs, it's possible to roll back to a previous
version of that package, and it's easy to do when we can identify the
package. We can simply cherry-pick it from a previous commit, or just
grab it from it's canonical source.

However, if the breakage manifests as a side-effect, identifying
the problem package is much harder.

To this end, I wrote this script to make each package have it's own
commit history, (starting today!)

In a nutshell, this script will accept the name of a package and
locate it from the folders in the current git staged/unstaged changes.

It will then create a single commit for the new version being added
and the old version(s) being removed (if it/they exists.)

Usage:
======

    git-elpa --list

List all updated packages, not yet committed.

    git-elpa --commit=package-name

Commit the package update (and old version removal). Tthe following
automatic commit message pattern will be used:

"[package-name upgraded] to NEW_VERSION from OLD_VERSION"

    git-elpa --all

Commit all updated packages (as individual commits)

=end

require 'git'

class GitElpa

  EMACS_D = File.join(Dir.home, ".emacs.d")
  
  def initialize
    @g = Git.open EMACS_D
  end

  def updated_packages
    elpa_rx = Regexp.new("^elpa/(.*?)/")
    package_name = Regexp.new("^(.*)-.*?$")
    updatable = (
      @g.status.untracked.map(&:first) +
      @g.status.deleted.map(&:first)
    ).collect { |f| elpa_rx.match(f)[1] if elpa_rx.match(f) }.
                compact.
                uniq.
                sort
    
    updatable.map {|u| package_name.match(u)[1] if package_name.match(u) }.
      uniq
    if updatable.length > 0
      updatable
    else
      abort "There are updated packages / no commits required"
    end
  end
  
  def commit_all_packages        
    updated_packages.each do |p|
      commit_package p
    end
  end

  def commit_package(package, do_commit = true)
    @package = package
    @rx = Regexp.new("(^elpa/)(#{@package})-([^-]*?)/(.*)")
    if do_commit
      puts "Committing updated package: #{package}"          
      commit
    end
  end

  def commit_message
    old = old_versions
    ver = new_version

    abort "No new version found for #{@package}" if ver == nil

    return "[Updating #{@package}] version: #{ver} [removing old versions: #{old.join(',')}]" if old.length > 1
    return "[Updating #{@package}] version: #{ver} [removing old version: #{old.first}]"      if old.length == 1
    return "[Adding #{@package}] version: #{ver}"                                             if old.length == 0
  end

  def add_to_index
    @g.add new_version_files
    @g.remove old_version_files
  end

  def commit(message = commit_message, add = true)
    add_to_index if add
    @g.commit message
  end

  def new_version
    versions = new_version_files.map{|f| @rx.match(f)[3] }.uniq
    if versions.length > 1
      abort "There are more than one new versions of #{@package}"
    end
    versions.first
  end

  def old_versions
    old_version_files.map{|f| @rx.match(f)[3] }.uniq
  end

  def new_version_files
    (@g.status.untracked.map(&:first) + @g.status.added.map(&:first)).select{|f| @rx.match(f) }
  end

  def old_version_files
    @g.status.deleted.map(&:first).select{|f| @rx.match(f) }
  end
end

require 'optparse'

option_parser = OptionParser.new do |opts| 
  elpa = GitElpa.new() 
  opts.banner = "
Emacs ELPA package commit tool

This tool is designed to assist the storage of your installed ELPA packages.
It will commit each package separately.

Usage: git-elpa [options]
"

  opts.on "-l", "--list", "List updated packages" do 
    puts "Listing updated ELPA packages...(to be committed)", ""
    puts elpa.updated_packages
    exit 0
  end
  
  opts.on "-cPACKAGE", "--commit=PACKAGE", "Commit a new/updated elpa package" do |package|    
    elpa.commit_package package
    exit 0
  end

  opts.on "-A", "--all", "Commit all updated elpa packages (as individual commits)" do
    puts <<-EOD.gsub(/^ */,'')
        Commit all updated packages

        Current commit (for reset):
        #{`git log --pretty=oneline -1`}
    EOD
    elpa.commit_all_packages
    exit 0
  end
end

option_parser.parse!

puts option_parser
